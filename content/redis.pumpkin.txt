#TOPIC: Redis
#DESC: In-memory data store used for caching, queues, and real-time infrastructure.

##CONCEPT: Event loop and command execution
##PREREQ:
##SUMMARY: Redis processes commands on a single event loop, so long operations block everyone.

Q: You need to iterate a large keyspace in production without blocking the server. Which command should you use?
A) KEYS
B) SCAN
C) DUMP
D) FLUSHALL
ANS: B
EXPL: SCAN iterates incrementally, avoiding long blocking operations.
TAGS: ops,performance
DIFF: 2
---
Q: You must read a huge set with millions of members while keeping latency low. What should you use?
A) SMEMBERS
B) SSCAN with small batches
C) SUNIONSTORE
D) SPOP
ANS: B
EXPL: SSCAN paginates over large sets to avoid blocking the event loop.
TAGS: performance,sets
DIFF: 2
---
TYPE: TWO_STEP
Q: A client receives large replies and then stops reading. What happens first?
A) Redis evicts keys
B) Client output buffers grow and latency spikes
C) Redis restarts automatically
D) Cluster resharding begins
REASON: Why does that happen?
REASON_A) The event loop must buffer replies for slow clients
REASON_B) Replies are discarded immediately
REASON_C) Slow clients speed up the loop
REASON_D) Replication disables buffers
ANS: B,A
EXPL: Slow clients create backpressure; output buffers grow and stall the event loop.
TAGS: performance,networking
DIFF: 3

##CONCEPT: Data modeling and structures
##PREREQ: Event loop and command execution
##SUMMARY: Choosing the right structure keeps operations fast and predictable.

Q: You store user profiles with many fields and update one field at a time. Which structure fits best?
A) String
B) Hash
C) List
D) HyperLogLog
ANS: B
EXPL: Hashes store field-value pairs efficiently for object-like data.
TAGS: data-modeling
DIFF: 1
---
Q: You need a leaderboard that returns the top 10 users by score quickly. Which structure should you use?
A) Set
B) Sorted set
C) List
D) Stream
ANS: B
EXPL: Sorted sets order members by score and support fast range queries.
TAGS: data-modeling,ranking
DIFF: 2
---
TYPE: TWO_STEP
Q: You need approximate unique visitor counts with fixed memory usage. What should you use?
A) Set
B) HyperLogLog
C) Bitmap
D) List
REASON: Why is that the right choice?
REASON_A) It uses probabilistic counting with fixed memory
REASON_B) It stores every value exactly
REASON_C) It sorts values by score
REASON_D) It keeps a time-ordered log
ANS: B,A
EXPL: HyperLogLog provides approximate cardinality with tiny fixed memory.
TAGS: data-modeling,analytics
DIFF: 3

##CONCEPT: Expiration and eviction
##PREREQ: Data modeling and structures
##SUMMARY: TTL expiration is per key; eviction happens only under memory pressure.

Q: You want cache entries to expire 10 minutes after write. Which command pattern fits?
A) SET key value EX 600
B) SET key value NX
C) PERSIST key
D) MIGRATE key
ANS: A
EXPL: EX sets a TTL at write time so the key expires automatically.
TAGS: ttl,caching
DIFF: 1
---
Q: Writes fail with "OOM command not allowed" even though many keys have TTLs. What is the likely cause?
A) maxmemory-policy is noeviction
B) Replication is disabled
C) AOF is off
D) Cluster slots are full
ANS: A
EXPL: With noeviction, Redis refuses writes instead of evicting keys when memory is full.
TAGS: memory,eviction
DIFF: 2
---
TYPE: TWO_STEP
Q: You want eviction to target only keys that already have TTLs. Which policy should you use?
A) allkeys-lru
B) volatile-lru
C) allkeys-random
D) noeviction
REASON: Why does that match the requirement?
REASON_A) volatile policies consider only keys with TTLs
REASON_B) allkeys policies ignore TTLs entirely
REASON_C) noeviction evicts only TTL keys
REASON_D) random eviction targets expired keys first
ANS: B,A
EXPL: volatile-lru evicts among keys with TTLs, preserving non-expiring data.
TAGS: memory,eviction
DIFF: 3

##CONCEPT: Persistence and durability
##PREREQ: Expiration and eviction
##SUMMARY: RDB snapshots and AOF logs trade off speed, size, and data loss.

Q: You can tolerate losing the last few minutes of data but want fast restarts. Which persistence should you choose?
A) RDB snapshots
B) AOF fsync always
C) No persistence
D) Cluster only
ANS: A
EXPL: RDB snapshots are compact and restore quickly, with some data loss between snapshots.
TAGS: persistence
DIFF: 2
---
Q: You want to minimize data loss to about one second while keeping performance reasonable. Which AOF fsync setting fits?
A) always
B) everysec
C) no
D) offload
ANS: B
EXPL: everysec is the common durability and performance balance and limits loss to about one second.
TAGS: persistence,durability
DIFF: 2
---
TYPE: TWO_STEP
Q: Your AOF file grows very large. What should you do to compact it?
A) Disable AOF permanently
B) Trigger an AOF rewrite
C) Delete the file and restart
D) Switch to RDB only without backup
REASON: Why does that help?
REASON_A) The rewrite compacts history into minimal commands
REASON_B) It removes all data
REASON_C) It doubles file size
REASON_D) It disables persistence entirely
ANS: B,A
EXPL: AOF rewrite rebuilds the log with the minimal commands needed for the current dataset.
TAGS: persistence,operations
DIFF: 3

##CONCEPT: Replication and failover
##PREREQ: Persistence and durability
##SUMMARY: Replication is async by default; Sentinel automates failover.

Q: Users reading from a replica see stale data after writes. Why does this happen?
A) Replication is asynchronous by default
B) Replicas are always ahead of the master
C) TTLs are ignored on replicas
D) AOF is disabled
ANS: A
EXPL: Replicas apply updates after the master, so reads can be stale.
TAGS: replication
DIFF: 2
---
Q: You need automatic failover for a primary node. What should you deploy?
A) Redis Sentinel
B) AOF rewrite
C) MONITOR
D) Slowlog
ANS: A
EXPL: Sentinel monitors masters and coordinates automated failover.
TAGS: ha,replication
DIFF: 2
---
TYPE: TWO_STEP
Q: You want to reduce the risk of losing recent writes during failover. What should you use?
A) WAIT for replica acknowledgments
B) Disable replication
C) Increase maxmemory
D) Use KEYS more often
REASON: Why does that help?
REASON_A) WAIT blocks until replicas confirm they received the write
REASON_B) Disabling replication improves durability
REASON_C) maxmemory controls replication lag
REASON_D) KEYS forces replicas to sync
ANS: A,A
EXPL: WAIT ensures writes are replicated to a quorum before continuing, reducing loss on failover.
TAGS: replication,durability
DIFF: 3

##CONCEPT: Cluster sharding and multi-key operations
##PREREQ: Replication and failover
##SUMMARY: Redis Cluster partitions keys into hash slots and limits multi-key atomicity.

Q: Your dataset no longer fits on a single node. Which Redis mode provides horizontal sharding?
A) Redis Cluster
B) Redis Sentinel
C) RDB only
D) MONITOR
ANS: A
EXPL: Redis Cluster shards data across nodes using hash slots.
TAGS: cluster,scaling
DIFF: 2
---
Q: Multi-key commands fail with CROSSSLOT. What is the correct fix?
A) Disable clustering
B) Use hash tags to force keys into the same slot
C) Increase maxmemory
D) Use KEYS before every command
ANS: B
EXPL: Hash tags inside {} ensure related keys map to the same slot.
TAGS: cluster,modeling
DIFF: 3
---
TYPE: TWO_STEP
Q: A Lua script touches multiple keys and fails in Cluster. Why?
A) Lua scripts are disabled
B) Keys are in different hash slots
C) AOF is off
D) Replicas are read-only
REASON: Why does that cause a failure?
REASON_A) Cluster requires all keys in a script to be in the same hash slot
REASON_B) Lua scripts run only on replicas
REASON_C) AOF controls slot mapping
REASON_D) Scripts cannot read keys
ANS: B,A
EXPL: Cluster enforces single-slot atomicity, so scripts cannot span multiple hash slots.
TAGS: cluster,scripting
DIFF: 3

##CONCEPT: Atomicity and Lua scripts
##PREREQ: Cluster sharding and multi-key operations
##SUMMARY: MULTI/EXEC and Lua scripts provide atomic updates when used carefully.

Q: You must atomically check a balance and decrement it. What is the safest approach?
A) Two separate GET and SET commands
B) A Lua script that reads and updates in one call
C) A client-side lock only
D) A Pub/Sub message
ANS: B
EXPL: Lua scripts run atomically on the server, ensuring the check and update happen together.
TAGS: atomicity,scripting
DIFF: 2
---
Q: You want an optimistic transaction that aborts if a key changes. What should you use?
A) WATCH with MULTI/EXEC
B) PING
C) SETNX only
D) KEYS
ANS: A
EXPL: WATCH marks keys so the transaction aborts if they change before EXEC.
TAGS: atomicity,transactions
DIFF: 2
---
TYPE: TWO_STEP
Q: A long-running Lua script causes latency spikes for all clients. Why is that?
A) Scripts run in a separate background thread
B) Scripts block the single event loop
C) Scripts are read-only and slow
D) Scripts force replication to stop
REASON: Why does that impact other commands?
REASON_A) Redis processes commands sequentially on one thread
REASON_B) Scripts disable persistence
REASON_C) Replicas cannot apply scripts
REASON_D) Lua bypasses the event loop
ANS: B,A
EXPL: Lua scripts run on the main thread, so long scripts block all other commands.
TAGS: atomicity,performance
DIFF: 3

##CONCEPT: Performance and latency
##PREREQ: Atomicity and Lua scripts
##SUMMARY: Network round trips and large keys are common latency killers.

Q: Your app sends many small commands with high network RTT. What should you use?
A) Pipelining
B) MONITOR
C) KEYS
D) FLUSHALL
ANS: A
EXPL: Pipelining batches commands to reduce round trips and latency.
TAGS: performance,networking
DIFF: 2
---
Q: You want to identify commands that exceed a latency threshold. Which tool should you use?
A) SLOWLOG
B) INFO REPLICATION
C) DBSIZE
D) CLUSTER NODES
ANS: A
EXPL: SLOWLOG records commands that exceed the configured slowlog threshold.
TAGS: ops,performance
DIFF: 2
---
TYPE: TWO_STEP
Q: A single key stores a huge list and operations stall the server. What should you do?
A) Split the data into smaller keys or shards
B) Increase client output buffers
C) Use KEYS more often
D) Disable persistence
REASON: Why does that help?
REASON_A) Large operations block the single thread; smaller keys reduce blocking work
REASON_B) Buffers solve large key latency
REASON_C) KEYS speeds up large lists
REASON_D) Persistence controls list size
ANS: A,A
EXPL: Large keys cause long-running commands; splitting reduces blocking and latency.
TAGS: performance,modeling
DIFF: 3

##CONCEPT: Streams and messaging
##PREREQ: Performance and latency
##SUMMARY: Streams provide durable logs; Pub/Sub is ephemeral.

Q: You need a durable queue with replay and consumer groups. What should you use?
A) Pub/Sub
B) Streams
C) Lists with BLPOP only
D) PING
ANS: B
EXPL: Streams persist entries and support consumer groups with replay.
TAGS: streams,messaging
DIFF: 2
---
Q: You need multiple consumers to share work and track offsets. Which command pattern fits?
A) XREADGROUP with a consumer group
B) SUBSCRIBE
C) GET
D) SET
ANS: A
EXPL: Consumer groups track offsets per consumer with XREADGROUP.
TAGS: streams,consumers
DIFF: 2
---
TYPE: TWO_STEP
Q: Pending messages never complete and you need to recover them. What should you do?
A) Use XCLAIM to take ownership of pending entries
B) Delete the stream
C) Use PUBLISH
D) Use SETEX
REASON: Why does that work?
REASON_A) The PEL tracks unacknowledged entries that can be claimed
REASON_B) PUBLISH stores messages for replay
REASON_C) SETEX changes stream offsets
REASON_D) Deleting the stream is required
ANS: A,A
EXPL: XCLAIM lets another consumer take over messages in the pending entries list.
TAGS: streams,operations
DIFF: 3

##CONCEPT: Security and operations
##PREREQ: Streams and messaging
##SUMMARY: Secure defaults and diagnostics keep production Redis safe.

Q: A Redis instance is accidentally exposed to the internet. What is the most direct fix?
A) Bind Redis to a private interface and firewall access
B) Disable AOF
C) Increase maxmemory
D) Enable pipelining
ANS: A
EXPL: Binding to a private interface and firewalling blocks public access.
TAGS: security
DIFF: 2
---
Q: You want to allow an app to run only GET and SET on specific keys. What should you use?
A) ACL users with command and key patterns
B) RDB snapshots
C) Client tracking
D) MONITOR
ANS: A
EXPL: ACLs define per-user command and key access patterns.
TAGS: security,acl
DIFF: 2
---
TYPE: TWO_STEP
Q: Memory usage grows and you suspect fragmentation. Which command should you run?
A) MEMORY DOCTOR
B) SLOWLOG RESET
C) LATENCY RESET
D) CLIENT KILL
REASON: Why is that helpful?
REASON_A) MEMORY DOCTOR reports fragmentation and allocator hints
REASON_B) SLOWLOG reports memory usage
REASON_C) LATENCY RESET frees memory
REASON_D) CLIENT KILL compacts memory
ANS: A,A
EXPL: MEMORY DOCTOR surfaces fragmentation and memory allocator issues for investigation.
TAGS: ops,memory
DIFF: 2
